{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/@rill/chain/index.js",
    "node_modules/@rill/error/index.js",
    "node_modules/@rill/http/adapter/browser.js",
    "node_modules/@rill/http/client/incoming-message.js",
    "node_modules/@rill/http/client/index.js",
    "node_modules/@rill/http/client/server-response.js",
    "node_modules/@rill/http/client/server.js",
    "node_modules/@rill/http/node_modules/global/window.js",
    "node_modules/@rill/https/client/index.js",
    "node_modules/browserify/node_modules/process/browser.js",
    "node_modules/byte-length/index.js",
    "node_modules/content-check/browser/buffer.js",
    "node_modules/content-check/browser/mime-types.js",
    "node_modules/content-check/index.js",
    "node_modules/cookie/index.js",
    "node_modules/events-light/src/index.js",
    "node_modules/get-loc/index.js",
    "node_modules/global/window.js",
    "node_modules/header-field/index.js",
    "node_modules/is-typeof/index.js",
    "node_modules/isarray/index.js",
    "node_modules/mini-querystring/index.js",
    "node_modules/mini-url/index.js",
    "node_modules/mini-url/src/browser.js",
    "node_modules/mini-url/src/parts.js",
    "node_modules/parse-form/index.js",
    "node_modules/path-to-regexp/index.js",
    "node_modules/q-flat/index.js",
    "node_modules/q-set/index.js",
    "node_modules/statuses/codes.json",
    "node_modules/statuses/index.js",
    "src/context.js",
    "src/index.js",
    "src/request.js",
    "src/respond.js",
    "src/response.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACbA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AClEA;AACA;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACvTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "'use strict'\nmodule.exports = chain\n\n/**\n * Chain a stack of rill middleware into one composed function.\n *\n * @param {Array<Function>}\n * @return {Function}\n */\nfunction chain (stack) {\n  if (!Array.isArray(stack)) throw new TypeError('Rill: Middleware stack must be an array.')\n  var fns = normalize(stack, [])\n\n  return function chained (ctx, next) {\n    var index = -1 // Last called middleware.\n    return dispatch(0)\n    function dispatch (i) {\n      if (i <= index) return Promise.reject(new Error('Rill: next() called multiple times.'))\n\n      var fn = fns[i] || next\n      index = i\n\n      if (!fn) {\n        return Promise.resolve()\n      }\n\n      try {\n        return Promise.resolve(fn(ctx, function next () {\n          return dispatch(i + 1)\n        }))\n      } catch (err) {\n        return Promise.reject(err)\n      }\n    }\n  }\n}\n\n/**\n * Utility to normalize a middleware stack and check for validity.\n *\n * @param {Array<Function>}\n * @throws {TypeError}\n */\nfunction normalize (stack, fns) {\n  var fn\n  var len = stack.length\n  for (var i = 0; i < len; i++) {\n    fn = stack[i]\n    if (!fn) continue\n    else if (typeof fn === 'function') fns.push(fn)\n    else if (Array.isArray(fn)) normalize(fn, fns)\n    else if (Array.isArray(fn.stack)) normalize(fn.stack, fns)\n    else throw new TypeError('Rill: Middleware must be an functions. Got a [' + fn.constructor.name + '].')\n  }\n\n  return fns\n}\n",
    "'use strict'\nvar STATUS_CODES = require(5).STATUS_CODES\nHttpError.prototype = new Error\nHttpError.fail = fail\nHttpError.assert = assert\nmodule.exports = HttpError\n\n/**\n * Creates a Rill HttpError.\n *\n * @param {String|Number} code - The status code for the error.\n * @param {String} [message] - Optional status message.\n * @param {Object} [meta] - Optional object to merge onto the error.\n */\nfunction HttpError (code, message, meta) {\n  if (typeof code !== 'number') throw new TypeError('Rill#HttpError.fail: Status code must be a number.')\n\n  this.name = 'HttpError'\n  this.code = code\n  this.message = message || STATUS_CODES[code]\n\n  for (var key in meta) this[key] = meta[key]\n  if (Error.captureStackTrace) Error.captureStackTrace(this, HttpError)\n  else Error.call(this)\n}\n\n/**\n * Throw an http error.\n *\n * @param {String|Number} code - The status code for the error.\n * @param {String} [message] - Optional status message.\n * @param {Object} [meta] - Optional object to merge onto the error.\n * @throws HttpError\n */\nfunction fail (code, message, meta) {\n  throw new HttpError(code, message, meta)\n}\n\n/**\n * Throw an http error if a value is not truthy.\n *\n * @param {*} val - The value to test for truthyness.\n * @param {String|Number} code - The status code for the error.\n * @param {String} [message] - Optional status message.\n * @param {Object} [meta] - Optional object to merge onto the error.\n * @throws HttpError\n */\nfunction assert (val, code, message, meta) {\n  if (!val) fail(code, message, meta)\n}\n",
    "'use strict'\n\nvar window = require(8)\nvar URL = require(23)\nvar parseForm = require(26)\nvar QS = require(22)\nvar location = require(17)()\nvar IncomingMessage = require(4)\nvar ServerResponse = require(6)\nvar history = window.history\nvar document = window.document\n\n// Expose browser hijacker.\nattachBrowser.fetch = fetch\nmodule.exports = attachBrowser['default'] = attachBrowser\n\n/**\n * Emulates node js http server in the browser by hijacking links and forms.\n *\n * @param {Server} server - The @rill/http server to attach to.\n * @param {boolean} [initialize=true] - If there should be an initial request.\n * @return {Server}\n */\nfunction attachBrowser (server, initialize) {\n  server._referrer = document && document.referrer\n  server._initialize = initialize !== false\n  server._pending_refresh = null\n  // Setup link/form hijackers.\n  server._onHistory = onHistory.bind(server)\n  server._onSubmit = onSubmit.bind(server)\n  server._onClick = onClick.bind(server)\n  // Register link/form hijackers.\n  server.prependListener('listening', onListening)\n  // Teardown link/form hijackers\n  server.prependListener('close', onClosing)\n  return server\n}\n\n/**\n * Add event listeners to the browser once the server has started listening.\n *\n * @return {void}\n */\nfunction onListening () {\n  window.addEventListener('popstate', this._onHistory)\n  window.addEventListener('submit', this._onSubmit)\n  window.addEventListener('click', this._onClick)\n  this.prependListener('request', onRequest)\n  // Trigger initial load event.\n  this._pending_load = this._initialize && setTimeout(this._onHistory, 0)\n}\n\n/**\n * Removes any attached event listeners once a server closes.\n *\n * @return {void}\n */\nfunction onClosing () {\n  window.removeEventListener('popstate', this._onHistory)\n  window.removeEventListener('submit', this._onSubmit)\n  window.removeEventListener('click', this._onClick)\n  this.removeListener('request', onRequest)\n  clearTimeout(this._pending_load)\n  clearTimeout(this._pending_refresh)\n}\n\n/**\n * Handle incomming requests and add a listener for when it is complete.\n *\n * @param {IncomingMessage} req - The mock server request.\n * @param {ServerResponse} res - The mock server response.\n * @return {void}\n */\nfunction onRequest (req, res) {\n  // Set referrer automatically.\n  req.headers.referer = req.headers.referer || req.socket.server._referrer\n  // Trigger cleanup on request finish.\n  res.once('finish', onFinish.bind(null, req, res))\n}\n\n/**\n * Handle completed requests by updating location, scroll, cookies, etc.\n *\n * @param {IncomingMessage} req - The mock server request.\n * @param {ServerResponse} res - The mock server response.\n * @return {void}\n */\nfunction onFinish (req, res) {\n  var parsed = req._options.parsed\n  var server = req.socket.server\n\n  // Any navigation during a 'refresh' will cancel the refresh.\n  clearTimeout(server._pending_refresh)\n\n  // Check if we should set some cookies.\n  var cookies = res.getHeader('set-cookie')\n  if (cookies && cookies.length) {\n    if (typeof cookies === 'string') {\n      // Set a single cookie.\n      document.cookie = cookies\n    } else {\n      // Set multiple cookie header.\n      for (var i = 0; i < cookies.length; i++) {\n        document.cookie = cookies[i]\n      }\n    }\n  }\n\n  // Check to see if a refresh was requested.\n  var refresh = res.getHeader('refresh')\n  if (refresh) {\n    var parts = refresh.split(' url=')\n    var timeout = parseInt(parts[0], 10) * 1000\n    var redirectURL = parts[1]\n    // This handles refresh headers similar to browsers by waiting a timeout, then navigating.\n    server._pending_refresh = setTimeout(\n      fetch.bind(null, server, { url: redirectURL }),\n      timeout\n    )\n  }\n\n  // We don't do hash scrolling or a url update unless it is a GET request.\n  if (req.method !== 'GET') return\n\n  // We don't do hash scrolling or a url update on redirects.\n  /* istanbul ignore next */\n  if (res.getHeader('location')) return\n\n  /*\n   * When navigating a user will be brought to the top of the page.\n   * If the urls contains a hash that is the id of an element (a target) then the target will be scrolled to.\n   * This is similar to how browsers handle page transitions natively.\n   */\n  /* istanbul ignore next */\n  if (req._scroll !== false) {\n    if (parsed.hash === '') window.scrollTo(0, 0)\n    else {\n      var target = document.getElementById(parsed.hash.slice(1))\n      /* istanbul ignore next */\n      if (target && target.scrollIntoView) {\n        target.scrollIntoView({\n          block: 'start',\n          // Only use smooth scrolling if we are on the page already.\n          behavior: (\n            location.pathname === parsed.pathname &&\n            (location.search || '') === (parsed.search || '')\n          ) ? 'smooth' : 'auto'\n        })\n      }\n    }\n  }\n\n  // Don't push the same url twice.\n  /* istanbul ignore next */\n  if (req.headers.referer === parsed.href) return\n  else server._referrer = parsed.href\n\n  // Update the href in the browser.\n  /* istanbul ignore next */\n  if (req._history !== false) {\n    history.pushState(null, document.title, req.url)\n  }\n}\n\n/**\n * Handles history state changes (back or startup) and pushes them through the server.\n *\n * @return {void}\n */\nfunction onHistory () {\n  fetch(this, { url: location.href, scroll: false, history: false })\n}\n\n/**\n * Handles intercepting forms and pushes them through the server.\n *\n * @param {object} e - The <form> submit event.\n * @return {void}\n */\nfunction onSubmit (e) {\n  // Ignore canceled events.\n  if (e.defaultPrevented) return\n\n  // Get the <form> element.\n  var el = e.target\n  /* istanbul ignore next */\n  var action = el.action || el.getAttribute('action') || ''\n  // Parse out host and protocol.\n  var parsed = URL.parse(action, location.href)\n\n  // Ignore the click if the element has a target.\n  if (el.target && el.target !== '_self') return\n  // Ignore links from different host.\n  if (parsed.host !== location.host) return\n  // Ignore links from different protocol.\n  if (parsed.protocol !== location.protocol) return\n\n  // Prevent default request.\n  e.preventDefault()\n\n  // Submit the form to the server.\n  /* istanbul ignore next */\n  fetch(this, { url: action, method: el.method || el.getAttribute('method'), form: el })\n\n  // Check for special data-noreset option (disables Automatically resetting the form.)\n  // This is not a part of the official API because I hate the name data-reset and I feel like there should be a better approach to this.\n  /* istanbul ignore next */\n  if (!el.hasAttribute('data-noreset')) el.reset()\n}\n\n/**\n * Handle intercepting link clicks and pushes them through the server.\n *\n * @param {object} e - The <a> click event.\n * @return {void}\n */\nfunction onClick (e) {\n  // Ignore canceled events, modified clicks, and right clicks.\n  if (\n    e.defaultPrevented ||\n    e.button ||\n    e.metaKey ||\n    e.ctrlKey ||\n    e.shiftKey\n  ) return\n\n  // Get the clicked element.\n  var el = e.target\n  // Find an <a> element that may have been clicked.\n  while (el != null && el.nodeName !== 'A') el = el.parentNode\n\n  // Ignore if we couldn't find a link.\n  if (!el) return\n  // Ignore clicks from linkless elements.\n  if (!el.href) return\n  // Ignore the click if the element has a target.\n  if (el.target && el.target !== '_self') return\n  // Ignore 'rel=\"external\"' links.\n  if (el.rel && el.rel === 'external') return\n  // Ignore download links\n  if (el.hasAttribute('download')) return\n  // Ignore links from different host.\n  if (el.host && el.host !== location.host) return\n  // Ignore links from different protocol.\n  if (el.protocol && el.protocol !== ':' && el.protocol !== location.protocol) return\n\n  // Attempt to navigate internally.\n  e.preventDefault()\n  fetch(this, el.href)\n}\n\n/**\n * Like native window.fetch but requests from a local mock server.\n *\n * @param {Server} server - The local server to fetch from.\n * @param {object} opts - Options about the request.\n * @param {boolean} opts.url - The url to navigate to.\n * @param {object} [opts.body] - An request body to pass through as is.\n * @param {HTMLElement} [opts.form] - A form to parse and pass through as the request body.\n * @param {boolean} [opts.scroll] - Should the request trigger a page scroll.\n * @param {boolean} [opts.history] - Should the request update the page url.\n * @param {string|false} [opts.redirect='follow'] - Should we follow any redirects.\n * @api private\n */\nfunction fetch (server, url, options) {\n  // Allow for both url string or { url: '...' } object.\n  if (typeof url === 'object') {\n    options = url\n  } else if (typeof url === 'string') {\n    options = options || {}\n    options.url = url\n  }\n\n  // Ensure url was a string.\n  if (!options || typeof options.url !== 'string') return Promise.reject(new TypeError('@rill/http/adapter/browser#fetch: url must be a string.'))\n\n  // Parse url parts into an object.\n  var parsed = options.parsed = URL.parse(options.url, location.href)\n\n  // Return a 'fetch' style response as a promise.\n  return new Promise(function (resolve, reject) {\n    // Create a nodejs style req and res.\n    var incomingMessage = IncomingMessage._createIncomingMessage(server, options)\n    var serverResponse = ServerResponse._createServerResponse(incomingMessage)\n    var form = options.form\n\n    // Handle special form option.\n    if (form) {\n      // Copy content type from form.\n      incomingMessage.headers['content-type'] = (\n        form.enctype ||\n        /* istanbul ignore next */\n        form.getAttribute('enctype') ||\n        /* istanbul ignore next */\n        'application/x-www-form-urlencoded'\n      )\n\n      // Parse form data and override options.\n      var formData = parseForm(form)\n      options.body = formData.body\n      options.files = formData.files\n    }\n\n    if (incomingMessage.method === 'GET') {\n      // On get requests with bodies we update the query string.\n      var query = options.query || options.body\n      if (query) {\n        parsed = options.parsed = URL.parse(\n          parsed.pathname + '?' + QS.stringify(query, true) + parsed.hash,\n          location.href\n        )\n      }\n    } else {\n      // Otherwise we pass through body data as is.\n      incomingMessage.body = options.body\n      incomingMessage.files = options.files\n    }\n\n    // Set some hidden browser specific options.\n    incomingMessage._scroll = options.scroll\n    incomingMessage._history = options.history\n\n    // Set the request url.\n    incomingMessage.url = parsed.pathname + parsed.search + parsed.hash\n\n    // Wait for server response to be sent.\n    serverResponse.once('finish', function handleResponseEnd () {\n      // Marks incomming message as complete.\n      incomingMessage.complete = true\n      incomingMessage.emit('end')\n\n      // Check to see if we should redirect.\n      var redirect = serverResponse.getHeader('location')\n      if (redirect) {\n        // Follow redirect if needed.\n        if (options.redirect === undefined || options.redirect === 'follow') {\n          return resolve(fetch(server, { url: redirect, history: options.history, scroll: options.scroll }))\n        }\n      }\n\n      // Send out final response data and meta data.\n      // This format allows for new Response(...data) when paired with the fetch api.\n      return resolve([serverResponse._body, {\n        url: incomingMessage.url,\n        headers: serverResponse.getHeaders(),\n        status: serverResponse.statusCode,\n        statusText: serverResponse.statusMessage\n      }])\n    })\n\n    // Trigger request event on server (ensured async).\n    setTimeout(server.emit.bind(server, 'request', incomingMessage, serverResponse), 0)\n  })\n}\n",
    "'use strict'\n\nvar EventEmitter = require(16)\n\n// Expose module.\nIncomingMessage._createIncomingMessage = createIncomingMessage\nmodule.exports = IncomingMessage['default'] = IncomingMessage\n\n/**\n * Emulates nodes IncomingMessage in the browser.\n * See: https://nodejs.org/api/http.html#http_class_http_incomingmessage\n *\n * @param {net.Socket} socket - An emulated node socket.\n * @constructor\n */\nfunction IncomingMessage (socket) {\n  this.headers = {}\n  this.socket = this.connection = socket\n}\n\n// Extend EventEmitter.\nIncomingMessage.prototype = Object.create(EventEmitter.prototype)\n\n// Static properties and type definitions.\n/** @type {number} */\nIncomingMessage.prototype.httpVersionMajor = 1\n\n/** @type {number} */\nIncomingMessage.prototype.httpVersionMinor = 1\n\n/** @type {string} */\nIncomingMessage.prototype.httpVersion = IncomingMessage.prototype.httpVersionMajor + '.' + IncomingMessage.prototype.httpVersionMinor\n\n/** @type {boolean} */\nIncomingMessage.prototype.complete = false\n\n/** @type {string} */\nIncomingMessage.prototype.url = ''\n\n/** @type {object} */\nIncomingMessage.prototype.headers = {}\n\n/** @type {string} */\nIncomingMessage.prototype.method = 'GET'\n\n/**\n * Creates a new incoming request and sets up some headers and other properties.\n *\n * @param {http.Server} server - The http server to create a request for.\n * @param {object} options - Options for the request.\n * @return {IncomingMessage}\n */\nfunction createIncomingMessage (server, options) {\n  var parsed = options.parsed\n  var incommingMessage = new IncomingMessage({\n    server: server,\n    remoteAddress: '127.0.0.1',\n    encrypted: parsed.protocol === 'https:'\n  })\n\n  // Set default headers.\n  var headers = incommingMessage.headers\n  headers['referer'] = headers['referer'] || headers['referrer']\n  headers['date'] = (new Date()).toUTCString()\n  headers['host'] = parsed.host\n  headers['cookie'] = document.cookie\n  headers['user-agent'] = navigator.userAgent\n  headers['accept-language'] = navigator.language\n  headers['connection'] = 'keep-alive'\n  headers['cache-control'] = 'max-age=0'\n  headers['accept'] = '*/*'\n\n  // Attach headers from request\n  var reqHeaders = normalizeHeaders(options.headers)\n  for (var header in reqHeaders) headers[header] = reqHeaders[header]\n\n  // Setup other properties.\n  incommingMessage.method = options.method ? options.method.toUpperCase() : 'GET'\n  incommingMessage._options = options\n\n  return incommingMessage\n}\n\n/**\n * Converts a headers object to a regular object.\n *\n * @param {object} headers - The headers to normalize.\n * @return {object}\n */\nfunction normalizeHeaders (headers) {\n  if (headers == null || typeof headers.forEach !== 'function') return headers\n  var result = {}\n  headers.forEach(function (value, header) { result[header] = value })\n  return result\n}\n",
    "'use strict'\n\nvar Server = require(7)\nvar IncomingMessage = require(4)\nvar ServerResponse = require(6)\nvar STATUS_CODES = require(30)\n\n/** @type {object} */\nexports.STATUS_CODES = STATUS_CODES\n\n/** @type {string[]} */\nexports.METHODS = [\n  'OPTIONS',\n  'HEAD',\n  'GET',\n  'PUT',\n  'POST',\n  'PATCH',\n  'DELETE'\n]\n\n/** @type {Server} */\nexports.Server = Server\n\n/** @type {IncomingMessage} */\nexports.IncomingMessage = IncomingMessage\n\n/** @type {ServerResponse} */\nexports.ServerResponse = ServerResponse\n\n/**\n * Creates a new mock http server in the browser.\n *\n * @return {Server}\n */\nexports.createServer = function () {\n  var onRequest = arguments[arguments.length - 1]\n  return new Server(onRequest)\n}\n",
    "'use strict'\n\nvar EventEmitter = require(16)\nvar STATUS_CODES = require(30)\n\n// Expose module.\nServerResponse._createServerResponse = createServerResponse\nmodule.exports = ServerResponse['default'] = ServerResponse\n\n/**\n * Emulates nodes ServerResponse in the browser.\n * See: https://nodejs.org/api/http.html#http_class_http_serverresponse\n *\n * @param {IncomingMessage} incomingMessage - The request to the server.\n * @constructor\n */\nfunction ServerResponse (incomingMessage) {\n  this._headers = {}\n  this.socket = this.connection = incomingMessage.socket\n}\n\n// Extend EventEmitter.\nServerResponse.prototype = Object.create(EventEmitter.prototype)\n\n// Static properties and type definitions.\n/** @type {number} */\nServerResponse.prototype.statusCode = null\n\n/** @type {string} */\nServerResponse.prototype.statusMessage = null\n\n/** @type {boolean} */\nServerResponse.prototype.sendDate = true\n\n/** @type {boolean} */\nServerResponse.prototype.finished = false\n\n/** @type {boolean} */\nServerResponse.prototype.headersSent = false\n\n/** @type {Function} */\nServerResponse.prototype.writeContinue =\n\n/** @type {Function} */\nServerResponse.prototype.setTimeout =\n\n/** @type {Function} */\nServerResponse.prototype.addTrailers = function () {}\n\n/**\n * Writes data to the current ServerResponse body.\n *\n * @param {Buffer|ArrayBuffer|string[]} chunk - The chunk of data to write.\n * @param {string} [encoding] - The encoding for the chunk.\n * @param {Function} [onFinish] - A function that will be called when the response has finished.\n */\nServerResponse.prototype.write = function (chunk, encoding, onFinish) {\n  this._body.push(chunk)\n\n  if (typeof encoding === 'function') {\n    onFinish = encoding\n    encoding = null\n  }\n\n  if (typeof onFinish === 'function') {\n    this.once('finish', onFinish)\n  }\n}\n\n/**\n * Write status, status message and headers to the current ServerResponse.\n *\n * @param {number} [statusCode] - The status code to write.\n * @param {string} [string] - The status message to write.\n * @param {object} [headers] - An object containing headers to write.\n */\nServerResponse.prototype.writeHead = function writeHead (statusCode, statusMessage, headers) {\n  if (this.finished) return\n\n  this.statusCode = statusCode\n  this.headersSent = true\n  if (statusMessage) {\n    if (typeof statusMessage === 'object') {\n      headers = statusMessage\n    } else {\n      this.statusMessage = statusMessage\n    }\n  }\n\n  if (typeof headers === 'object') {\n    for (var key in headers) {\n      this.setHeader(key, headers[key])\n    }\n  }\n}\n\n/**\n * Get a shallow copy of all response header names.\n *\n * @return {object}\n */\nServerResponse.prototype.getHeaders = function getHeaders () {\n  var clone = {}\n  for (var key in this._headers) clone[key] = this._headers[key]\n  return clone\n}\n\n/**\n * Get a list of current header names.\n *\n * @return {string[]}\n */\nServerResponse.prototype.getHeaderNames = function getHeaderNames () {\n  return Object.keys(this._headers)\n}\n\n/**\n * Get a header from the current ServerResponse.\n *\n * @param {string} header - The name of the header to get.\n * @return {string[]|string|void}\n */\nServerResponse.prototype.getHeader = function getHeader (header) {\n  return this._headers[header.toLowerCase()]\n}\n\n/**\n * Check if a header has been set.\n *\n * @param {string} header - The name of the header to check.\n * @return {boolean}\n */\nServerResponse.prototype.hasHeader = function hasHeader (header) {\n  return header.toLowerCase() in this._headers\n}\n\n/**\n * Remove a header from the current ServerResponse.\n */\nServerResponse.prototype.removeHeader = function removeHeader (header) {\n  delete this._headers[header.toLowerCase()]\n}\n\n/**\n * Write a header to the current ServerResponse.\n *\n * @param {string} header - The name of the header to set.\n * @param {string[]|string} - The value for the header.\n */\nServerResponse.prototype.setHeader = function setHeader (header, value) {\n  this._headers[header.toLowerCase()] = value\n}\n\n/**\n * Handle event ending from the current ServerResponse.\n *\n * @param {Buffer|ArrayBuffer|string[]} [chunk] - A chunk of data to write.\n * @param {string} [encoding] - The encoding for the chunk.\n * @param {Function} [onFinish] - A function that will be called when the response has finished.\n */\nServerResponse.prototype.end = function end (chunk, encoding, onFinish) {\n  if (this.finished) return\n\n  if (typeof chunk === 'function') {\n    onFinish = chunk\n    chunk = null\n  } else if (typeof encoding === 'function') {\n    onFinish = encoding\n    encoding = null\n  }\n\n  if (chunk != null) {\n    this._body.push(chunk)\n  }\n\n  if (typeof onFinish === 'function') {\n    this.once('finish', onFinish)\n  }\n\n  if (this.statusCode == null) {\n    this.statusCode = 200\n  }\n\n  if (this.statusMessage == null) {\n    this.statusMessage = STATUS_CODES[this.statusCode]\n  }\n\n  if (this.sendDate) {\n    this._headers['date'] = (new Date()).toUTCString()\n  }\n\n  this._headers['status'] = this.statusCode\n  this.headersSent = true\n  this.finished = true\n  this.emit('finish')\n}\n\n/**\n * Creates a new server response and sets up some properties.\n *\n * @param {IncomingMessage} incomingMessage - The request that is assosiated with the response.\n * @return {ServerResponse}\n */\nfunction createServerResponse (incomingMessage) {\n  var serverResponse = new ServerResponse(incomingMessage)\n  serverResponse._body = []\n  return serverResponse\n}\n",
    "'use strict'\n\nvar EventEmitter = require(16)\n\n// Expose module.\nmodule.exports = Server['default'] = Server\n\n/**\n * Emulates node js http server in the browser.\n *\n * @param {Function} [onRequest] - A function that will be called on every request.\n */\nfunction Server (onRequest) {\n  if (onRequest) this.on('request', onRequest)\n}\n\n// Extend EventEmitter.\nServer.prototype = Object.create(EventEmitter.prototype)\n\n/**\n * Starts a server and sets listening to true.\n * Adapters will hook into this to startup routers on individual platforms.\n *\n * @param {...any}\n * @param {Function} [onListening] - A function that will be called once the server is listening.\n * @return {this}\n */\nServer.prototype.listen = function listen () {\n  // Automatically add callback `listen` handler.\n  var onListening = arguments[arguments.length - 1]\n  if (typeof onListening === 'function') this.once('listening', onListening)\n\n  // Ensure that listening is `async`.\n  setTimeout(function () {\n    // Mark server as listening.\n    this.listening = true\n    this.emit('listening')\n  }.bind(this), 0)\n\n  return this\n}\n\n/**\n * Closes the server and destroys all event listeners.\n *\n * @param {Function} [onClose] - A function that will be called once the server has closed.\n * @return {this}\n */\nServer.prototype.close = function close (onClose) {\n  // Automatically add callback `close` handler.\n  if (typeof onClose === 'function') this.once('close', onClose)\n\n  // Ensure that closing is `async`.\n  setTimeout(function () {\n    // Mark server as closed.\n    this.listening = false\n    this.emit('close')\n  }.bind(this), 0)\n\n  return this\n}\n",
    "var win;\n\nif (typeof window !== \"undefined\") {\n    win = window;\n} else if (typeof global !== \"undefined\") {\n    win = global;\n} else if (typeof self !== \"undefined\"){\n    win = self;\n} else {\n    win = {};\n}\n\nmodule.exports = win;\n",
    "'use strict'\n\nmodule.exports = require(5)\n",
    "// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n",
    "\"use strict\";\n\n/*\n * Calculate the byte lengths for utf8 encoded strings.\n *\n * @param {String} str\n * @return {Number}\n */\nmodule.exports = function byteLength (str) {\n  var i, len;\n  if (!str) return 0;\n  str = str.toString();\n\n  for (i = len = str.length; i--;) {\n    var code = str[i].charCodeAt();\n    if (0xDC00 <= code && code <= 0xDFFF) i--;\n    if (0x7f < code && code <= 0x7ff) len++;\n    else if (0x7ff < code && code <= 0xffff) len += 2;\n  }\n\n  return len;\n};\n",
    "\"use strict\";\n\n// Don't check buffer type in browser.\nmodule.exports = {\n\tBuffer: function () {}\n};\n",
    "\"use strict\";\n\n// We won't bother loading mime-types in the browser.\nmodule.exports = {\n\tlookup: function () {}\n};\n",
    "\"use strict\";\n\nvar htmlReg = /^\\s*</;\nvar buffer  = require(12).Buffer;\nvar lookup  = require(13).lookup;\n\n/**\n * Function that attempts to guess the content type for a value.\n *\n * Supports:\n * * text/plain\n * * text/html\n * * application/octet-stream\n * * application/json\n */\nmodule.exports = function checkContent (data) {\n\tif (data == null || typeof data === \"function\") return;\n\n\tif (typeof data === \"object\") {\n\t\tif (isBuffer(data)) {\n\t\t\treturn \"application/octet-stream\";\n\t\t} else if (isStream(data)) {\n\t\t\treturn lookup(data.path) || \"application/octet-stream\";\n\t\t} else if (isJSON(data)) {\n\t\t\treturn \"application/json; charset=UTF-8\";\n\t\t}\n\t}\n\n\treturn \"text/\" + (\n\t\thtmlReg.test(String(data))\n\t\t\t? \"html\"\n\t\t\t: \"plain\"\n\t) + \"; charset=UTF-8\";\n};\n\n/**\n * Test if a value is a node buffer.\n */\nfunction isBuffer (val) {\n\treturn val instanceof buffer;\n}\n\n/**\n * Test if a value is a node stream.\n */\nfunction isStream (val) {\n\treturn typeof val.pipe === \"function\";\n}\n\n/**\n * Test if a value can be json.\n */\nfunction isJSON (val) {\n\t// Try to check if JSON without stringify.\n\tif (\n\t\ttypeof val.toJSON === \"function\" ||\n\t\tval.constructor === Object ||\n\t\tval.constructor === Array\n\t) return true;\n\n\ttry {\n\t\tJSON.stringify(val);\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n}\n",
    "/*!\n * cookie\n * Copyright(c) 2012-2014 Roman Shtylman\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module exports.\n * @public\n */\n\nexports.parse = parse;\nexports.serialize = serialize;\n\n/**\n * Module variables.\n * @private\n */\n\nvar decode = decodeURIComponent;\nvar encode = encodeURIComponent;\nvar pairSplitRegExp = /; */;\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\n\nvar fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\n/**\n * Parse a cookie header.\n *\n * Parse the given cookie header string into an object\n * The object has the various cookies as keys(names) => values\n *\n * @param {string} str\n * @param {object} [options]\n * @return {object}\n * @public\n */\n\nfunction parse(str, options) {\n  if (typeof str !== 'string') {\n    throw new TypeError('argument str must be a string');\n  }\n\n  var obj = {}\n  var opt = options || {};\n  var pairs = str.split(pairSplitRegExp);\n  var dec = opt.decode || decode;\n\n  for (var i = 0; i < pairs.length; i++) {\n    var pair = pairs[i];\n    var eq_idx = pair.indexOf('=');\n\n    // skip things that don't look like key=value\n    if (eq_idx < 0) {\n      continue;\n    }\n\n    var key = pair.substr(0, eq_idx).trim()\n    var val = pair.substr(++eq_idx, pair.length).trim();\n\n    // quoted values\n    if ('\"' == val[0]) {\n      val = val.slice(1, -1);\n    }\n\n    // only assign once\n    if (undefined == obj[key]) {\n      obj[key] = tryDecode(val, dec);\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * serialize('foo', 'bar', { httpOnly: true })\n *   => \"foo=bar; httpOnly\"\n *\n * @param {string} name\n * @param {string} val\n * @param {object} [options]\n * @return {string}\n * @public\n */\n\nfunction serialize(name, val, options) {\n  var opt = options || {};\n  var enc = opt.encode || encode;\n\n  if (typeof enc !== 'function') {\n    throw new TypeError('option encode is invalid');\n  }\n\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError('argument name is invalid');\n  }\n\n  var value = enc(val);\n\n  if (value && !fieldContentRegExp.test(value)) {\n    throw new TypeError('argument val is invalid');\n  }\n\n  var str = name + '=' + value;\n\n  if (null != opt.maxAge) {\n    var maxAge = opt.maxAge - 0;\n    if (isNaN(maxAge)) throw new Error('maxAge should be a Number');\n    str += '; Max-Age=' + Math.floor(maxAge);\n  }\n\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError('option domain is invalid');\n    }\n\n    str += '; Domain=' + opt.domain;\n  }\n\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError('option path is invalid');\n    }\n\n    str += '; Path=' + opt.path;\n  }\n\n  if (opt.expires) {\n    if (typeof opt.expires.toUTCString !== 'function') {\n      throw new TypeError('option expires is invalid');\n    }\n\n    str += '; Expires=' + opt.expires.toUTCString();\n  }\n\n  if (opt.httpOnly) {\n    str += '; HttpOnly';\n  }\n\n  if (opt.secure) {\n    str += '; Secure';\n  }\n\n  if (opt.sameSite) {\n    var sameSite = typeof opt.sameSite === 'string'\n      ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n    switch (sameSite) {\n      case true:\n        str += '; SameSite=Strict';\n        break;\n      case 'lax':\n        str += '; SameSite=Lax';\n        break;\n      case 'strict':\n        str += '; SameSite=Strict';\n        break;\n      default:\n        throw new TypeError('option sameSite is invalid');\n    }\n  }\n\n  return str;\n}\n\n/**\n * Try decoding a string using a decoding function.\n *\n * @param {string} str\n * @param {function} decode\n * @private\n */\n\nfunction tryDecode(str, decode) {\n  try {\n    return decode(str);\n  } catch (e) {\n    return str;\n  }\n}\n",
    "/* jshint newcap:false */\nvar slice = Array.prototype.slice;\n\nfunction isFunction(arg) {\n    return typeof arg === 'function';\n}\n\nfunction checkListener(listener) {\n    if (!isFunction(listener)) {\n        throw TypeError('Invalid listener');\n    }\n}\n\nfunction invokeListener(ee, listener, args) {\n    switch (args.length) {\n        // fast cases\n        case 1:\n            listener.call(ee);\n            break;\n        case 2:\n            listener.call(ee, args[1]);\n            break;\n        case 3:\n            listener.call(ee, args[1], args[2]);\n            break;\n            // slower\n        default:\n            listener.apply(ee, slice.call(args, 1));\n    }\n}\n\nfunction addListener(eventEmitter, type, listener, prepend) {\n    checkListener(listener);\n\n    var events = eventEmitter.$e || (eventEmitter.$e = {});\n\n    var listeners = events[type];\n    if (listeners) {\n        if (isFunction(listeners)) {\n            events[type] = prepend ? [listener, listeners] : [listeners, listener];\n        } else {\n            if (prepend) {\n                listeners.unshift(listener);\n            } else {\n                listeners.push(listener);\n            }\n        }\n\n    } else {\n        events[type] = listener;\n    }\n    return eventEmitter;\n}\n\nfunction EventEmitter() {\n    this.$e = this.$e || {};\n}\n\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype = {\n    $e: null,\n\n    emit: function(type) {\n        var args = arguments;\n\n        var events = this.$e;\n        if (!events) {\n            return;\n        }\n\n        var listeners = events && events[type];\n        if (!listeners) {\n            // If there is no 'error' event listener then throw.\n            if (type === 'error') {\n                var error = args[1];\n                if (!(error instanceof Error)) {\n                    var context = error;\n                    error = new Error('Error: ' + context);\n                    error.context = context;\n                }\n\n                throw error; // Unhandled 'error' event\n            }\n\n            return false;\n        }\n\n        if (isFunction(listeners)) {\n            invokeListener(this, listeners, args);\n        } else {\n            listeners = slice.call(listeners);\n\n            for (var i=0, len=listeners.length; i<len; i++) {\n                var listener = listeners[i];\n                invokeListener(this, listener, args);\n            }\n        }\n\n        return true;\n    },\n\n    on: function(type, listener) {\n        return addListener(this, type, listener, false);\n    },\n\n    prependListener: function(type, listener) {\n        return addListener(this, type, listener, true);\n    },\n\n    once: function(type, listener) {\n        checkListener(listener);\n\n        function g() {\n            this.removeListener(type, g);\n\n            if (listener) {\n                listener.apply(this, arguments);\n                listener = null;\n            }\n        }\n\n        this.on(type, g);\n\n        return this;\n    },\n\n    // emits a 'removeListener' event iff the listener was removed\n    removeListener: function(type, listener) {\n        checkListener(listener);\n\n        var events = this.$e;\n        var listeners;\n\n        if (events && (listeners = events[type])) {\n            if (isFunction(listeners)) {\n                if (listeners === listener) {\n                    delete events[type];\n                }\n            } else {\n                for (var i=listeners.length-1; i>=0; i--) {\n                    if (listeners[i] === listener) {\n                        listeners.splice(i, 1);\n                    }\n                }\n            }\n        }\n\n        return this;\n    },\n\n    removeAllListeners: function(type) {\n        var events = this.$e;\n        if (events) {\n            delete events[type];\n        }\n    },\n\n    listenerCount: function(type) {\n        var events = this.$e;\n        var listeners = events && events[type];\n        return listeners ? (isFunction(listeners) ? 1 : listeners.length) : 0;\n    }\n};\n\nmodule.exports = EventEmitter;",
    "'use strict'\n\n// Better global support (for web/service workers)\nvar window = require(18)\n\n/**\n * Finds the location object, checking for polyfill and falling back to empty object.\n * @return {Object}\n */\nmodule.exports = function getLocation () {\n  return (window.history && window.history.location) || window.location || { href: '' }\n}\n",
    "if (typeof window !== \"undefined\") {\n    module.exports = window;\n} else if (typeof global !== \"undefined\") {\n    module.exports = global;\n} else if (typeof self !== \"undefined\"){\n    module.exports = self;\n} else {\n    module.exports = {};\n}\n",
    "\"use strict\";\n\nmodule.exports = field;\n\n/**\n * Converts hyphenated headers like `Content-Type` into `content-type`.\n */\nfunction field (str) {\n\tif (typeof str !== \"string\") throw new TypeError(\"Header Fields must be strings.\");\n\tstr = str.toLowerCase();\n\tif (str === \"referrer\") str = \"referer\";\n\treturn str;\n};\n",
    "'use strict'\n\nvar toString = Object.prototype.toString\nvar buffer = global.Buffer || noop\nvar typeClass = {\n  string: '[object String]',\n  number: '[object Number]',\n  boolean: '[object Boolean]',\n  date: '[object Date]',\n  regexp: '[object RegExp]',\n  error: '[object Error]',\n  function: '[object Function]',\n  arguments: '[object Arguments]',\n  object: '[object Object]',\n  array: '[object Array]'\n}\n\nmodule.exports = {\n  string: isType('String'),\n  number: isType('Number'),\n  boolean: isType('Boolean'),\n  date: isType('Date'),\n  regexp: isType('RegExp'),\n  error: isType('Error'),\n  function: isType('Function'),\n  arguments: isType('Arguments'),\n  object: isType('Object'),\n  array: isType('Array'),\n  stream: function isStream (val) {\n    return val != null && typeof val.pipe === 'function'\n  },\n  buffer: function isBuffer (val) {\n    return val instanceof buffer\n  },\n  empty: function isEmpty (val) {\n    /* eslint-disable */\n    for (var key in val) return false\n    /* eslint-enable */\n    return true\n  }\n}\n\n/**\n * Does nothing.\n */\nfunction noop () {}\n\n/*\n * Creates a type checker function based on the given type.\n *\n * @param {String} type\n * @api private\n */\nfunction isType (name) {\n  var type = name.toLowerCase()\n  return function (val) {\n    var _typeof = typeof val\n    switch (_typeof) {\n      case 'object':\n      case 'function':\n        return toString.call(val) === typeClass[type]\n      default:\n        return _typeof === type\n    }\n  }\n}\n",
    "module.exports = Array.isArray || function (arr) {\n  return Object.prototype.toString.call(arr) == '[object Array]';\n};\n",
    "'use strict'\n\nvar parseReg = /([^=?&]+)=?([^&]*)/g\nvar qFlat = require(28)\nvar qSet = require(29)\n\n/**\n * Converts an object to a query string and optionally flattens it.\n * @param  {Object} obj - the object to convert.\n * @return {String}\n */\nexports.stringify = function stringify (obj, flat) {\n  if (flat) obj = qFlat(obj)\n  var keys = Object.keys(obj)\n  if (!keys.length) return ''\n\n  for (var i = 0, len = keys.length, key; i < len; i++) {\n    key = keys[i]\n    keys[i] = encodeURIComponent(key) + '=' + encodeURIComponent(obj[key])\n  }\n\n  return keys.join('&')\n}\n\n/**\n * Parses a query string and optionally unflattens it.\n * @param  {String} str - the query string to parse.\n * @param  {Boolean} [deep] - if true the query will be unflattened.\n * @return {Object}\n */\nexports.parse = function (str, deep) {\n  var set = deep ? qSet : qSet.flat\n  var result = {}\n  var part\n\n  while ((part = parseReg.exec(str))) {\n    set(result, decodeURIComponent(part[1]), decodeURIComponent(part[2]))\n  }\n\n  return result\n}\n",
    "'use strict'\n\nvar URL = require(24)\nvar parts = require(25)\nvar seperator = '~#~'\nvar cache = {}\n\n// Expose parts for libraries built on top of this.\nexports.parts = parts\n\n// Expose cache for clearing.\nexports.cache = cache\n\n// Expose parser.\nexports.parse = parse\n\n// Expose stringify.\nexports.stringify = stringify\n\n/**\n * Exposes the url parsers and caches results.\n * @param  {String} path - the path for the url.\n * @param  {String} [base] - the base path for the url.\n * @return {URL}\n */\nfunction parse (path, base) {\n  var key = path + seperator + base\n  var result = cache[key]\n  if (!result) {\n    // Parse url and cache result.\n    var parsed = base\n      ? new URL(path, base)\n      : new URL(path)\n    result = {}\n\n    // Make each part default to empty string for consistency.\n    for (var i = parts.length, part, data; i--;) {\n      part = parts[i]\n      data = parsed[part]\n      if (data == null) data = ''\n      result[part] = data\n    }\n\n    // Freeze object to maintain cache.\n    result = cache[key] = Object.freeze(result)\n  }\n  return result\n}\n\n/**\n * Convertes a parsed url object into a string.\n * @param  {Object} parsed - the parsed url to convert to a string.\n * @return {String}\n */\nfunction stringify (parsed) {\n  if (typeof parsed !== 'object' || parsed == null) throw new TypeError('URL must be an object.')\n  return (\n    (parsed.protocol ? parsed.protocol + '//' : '') +\n    (parsed.host || (parsed.hostname || '') + (parsed.port ? ':' + parsed.port : '')) +\n    (parsed.pathname || '') +\n    (parsed.search || '') +\n    (parsed.hash || '')\n  )\n}\n",
    "'use strict'\n\nvar window = require(18)\nvar vendors = ['ms', 'moz', 'webkit', 'o']\nvar NativeURL = tryVendors(window, 'URL')\nvar supportsURL = false\n\n// Check if browser supports native url parser.\ntry {\n  supportsURL = Boolean(new NativeURL('', 'http://a'))\n} catch (e) {}\n\n// Try to use native url parser and fall back to <a> parser.\nif (supportsURL) {\n  module.exports = NativeURL\n} else if (window.document) {\n  // Load up a fake document to handle url resolution and parsing.\n  var getLocation = require(17)\n  var parts = require(25)\n  var doc = window.document.implementation.createHTMLDocument('parser')\n  var $base = doc.head.appendChild(doc.createElement('base'))\n  var $a = doc.createElement('a')\n\n  /**\n   * Creates a moch URL function using a link.\n   * @param {[type]} path [description]\n   * @param {[type]} base [description]\n   */\n  var URL = function URL (path, base) {\n    $base.href = base || getLocation().href\n    $a.href = path\n\n    for (var i = parts.length, part; i--;) {\n      part = parts[i]\n      this[part] = $a[part] || ''\n    }\n\n    // Patch for ie9 which excludes leading slash.\n    if (this.pathname[0] !== '/') {\n      this.pathname = '/' + this.pathname\n    }\n\n    // Patch for browsers automatically adding default ports.\n    if (this.port !== '') {\n      var href = this.href\n      var hostname = this.hostname\n      var hostIndex = href.indexOf(hostname) + hostname.length + 1\n      var expectedPort = href.slice(hostIndex, hostIndex + this.port.length)\n      if (expectedPort !== this.port) {\n        this.port = ''\n        this.host = this.hostname\n      }\n    }\n  }\n\n  /**\n   * Get the href for the url.\n   * @return {String} the href for the url.\n   */\n  URL.prototype.toString = function toString () {\n    return this.href\n  }\n\n  module.exports = URL\n} else {\n  throw new Error('URL parser not supported.')\n}\n\n/**\n * Check for vendored versions of function\n * @param  {Object} obj - the object to check in.\n * @param  {String} field - the field we are looking for.\n * @return {*|undefined}\n */\nfunction tryVendors (obj, field) {\n  if (obj[field]) return obj[field]\n  for (var i = vendors.length, alias; i--;) {\n    alias = obj[vendors[i] + field]\n    if (alias) return alias\n  }\n}\n",
    "'use strict'\n\n/**\n * Parts of the url to extract.\n * @type {Array}\n */\nmodule.exports = [\n  'protocol',\n  'hostname',\n  'pathname',\n  'search',\n  'host',\n  'port',\n  'hash',\n  'href'\n]\n",
    "'use strict'\n\nvar qset = require(29)\nvar fset = qset.flat\nvar validTags = {\n  INPUT: true,\n  TEXTAREA: true,\n  SELECT: true,\n  BUTTON: true\n}\n\n/**\n * Tracks which button submitted a form last.\n */\nvar _clickTarget = null\nwindow.addEventListener('click', function patchActiveElement (e) {\n  // Ignore canceled events, modified clicks, and right clicks.\n  if (\n    e.defaultPrevented ||\n    e.metaKey ||\n    e.ctrlKey ||\n    e.shiftKey ||\n    e.button !== 0\n    ) return\n  var el = e.target\n  // Find an <button> element that may have been clicked.\n  while (el != null && (el.nodeName !== 'BUTTON' || el.type !== 'submit')) el = el.parentNode\n  // Store the button that was clicked.\n  _clickTarget = el\n})\n\n/**\n * Patch for document.activeElement for safari.\n */\nfunction getActiveElement () {\n  var el = document.activeElement === document.body\n    ? _clickTarget\n    : document.activeElement\n  _clickTarget = null\n  return el\n}\n\n/*\n * Serialize a html form as JS object.\n *\n * @param {<Form/>} form\n * @returns { Array<Array> }\n */\nmodule.exports = function parseForm (form, flat) {\n  if (!form || form.nodeName !== 'FORM') {\n    throw new Error('Can only parse form elements.')\n  }\n\n  var set = flat ? fset : qset\n  var isMultiPart = form.enctype === 'multipart/form-data'\n  var nodes = form.elements\n  var body = {}\n  var files = isMultiPart ? {} : undefined\n\n  for (var i = 0, len = nodes.length; i < len; i++) {\n    var el = nodes[i]\n\n    // Check if this el should be serialized.\n    if (el.disabled || !(el.name && validTags[el.nodeName])) {\n      continue\n    }\n\n    var name = el.name\n    var options = el.options\n\n    switch (el.type) {\n      case 'submit':\n        // We check if the submit button is active\n        // otherwise all type=submit buttons would be serialized.\n        if (el === getActiveElement()) set(body, name, el.value)\n        break\n      case 'checkbox':\n      case 'radio':\n        if (el.checked) set(body, name, el.value)\n        break\n      case 'select-one':\n        if (el.selectedIndex >= 0) set(body, name, options[el.selectedIndex].value)\n        break\n      case 'select-multiple':\n        var selected = []\n        var option\n        for (var _a = 0, _lenA = options.length; _a < _lenA; _a++) {\n          option = options[_a]\n          if (option && option.selected) selected.push(option.value)\n        }\n\n        set(body, name, selected)\n        break\n      case 'file':\n        var fileList = el.files\n        if (isMultiPart && fileList) {\n          for (var _b = 0, _lenB = fileList.length; _b < _lenB; _b++) {\n            set(files, name, fileList[_b])\n          }\n        }\n        break\n      default:\n        set(body, name, el.value)\n    }\n  }\n\n  return {\n    body: body,\n    files: files\n  }\n}\n",
    "var isarray = require(21)\n\n/**\n * Expose `pathToRegexp`.\n */\nmodule.exports = pathToRegexp\nmodule.exports.parse = parse\nmodule.exports.compile = compile\nmodule.exports.tokensToFunction = tokensToFunction\nmodule.exports.tokensToRegExp = tokensToRegExp\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nvar PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  var tokens = []\n  var key = 0\n  var index = 0\n  var path = ''\n  var defaultDelimiter = options && options.delimiter || '/'\n  var res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    var m = res[0]\n    var escaped = res[1]\n    var offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    var next = str[index]\n    var prefix = res[2]\n    var name = res[3]\n    var capture = res[4]\n    var group = res[5]\n    var modifier = res[6]\n    var asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    var partial = prefix != null && next != null && next !== prefix\n    var repeat = modifier === '+' || modifier === '*'\n    var optional = modifier === '?' || modifier === '*'\n    var delimiter = res[2] || defaultDelimiter\n    var pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter: delimiter,\n      optional: optional,\n      repeat: repeat,\n      partial: partial,\n      asterisk: !!asterisk,\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nfunction compile (str, options) {\n  return tokensToFunction(parse(str, options))\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str) {\n  return encodeURI(str).replace(/[\\/?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURI(str).replace(/[?#]/g, function (c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens) {\n  // Compile all the tokens into regexps.\n  var matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (var i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$')\n    }\n  }\n\n  return function (obj, opts) {\n    var path = ''\n    var data = obj || {}\n    var options = opts || {}\n    var encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      var value = data[token.name]\n      var segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (isarray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (var j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|\\/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$\\/()])/g, '\\\\$1')\n}\n\n/**\n * Attach the keys as a property of the regexp.\n *\n * @param  {!RegExp} re\n * @param  {Array}   keys\n * @return {!RegExp}\n */\nfunction attachKeys (re, keys) {\n  re.keys = keys\n  return re\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options.sensitive ? '' : 'i'\n}\n\n/**\n * Pull out keys from a regexp.\n *\n * @param  {!RegExp} path\n * @param  {!Array}  keys\n * @return {!RegExp}\n */\nfunction regexpToRegexp (path, keys) {\n  // Use a negative lookahead to match only capturing groups.\n  var groups = path.source.match(/\\((?!\\?)/g)\n\n  if (groups) {\n    for (var i = 0; i < groups.length; i++) {\n      keys.push({\n        name: i,\n        prefix: null,\n        delimiter: null,\n        optional: false,\n        repeat: false,\n        partial: false,\n        asterisk: false,\n        pattern: null\n      })\n    }\n  }\n\n  return attachKeys(path, keys)\n}\n\n/**\n * Transform an array into a regexp.\n *\n * @param  {!Array}  path\n * @param  {Array}   keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction arrayToRegexp (path, keys, options) {\n  var parts = []\n\n  for (var i = 0; i < path.length; i++) {\n    parts.push(pathToRegexp(path[i], keys, options).source)\n  }\n\n  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options))\n\n  return attachKeys(regexp, keys)\n}\n\n/**\n * Create a path regexp from string input.\n *\n * @param  {string}  path\n * @param  {!Array}  keys\n * @param  {!Object} options\n * @return {!RegExp}\n */\nfunction stringToRegexp (path, keys, options) {\n  return tokensToRegExp(parse(path, options), keys, options)\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n *\n * @param  {!Array}          tokens\n * @param  {(Array|Object)=} keys\n * @param  {Object=}         options\n * @return {!RegExp}\n */\nfunction tokensToRegExp (tokens, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  var strict = options.strict\n  var end = options.end !== false\n  var route = ''\n\n  // Iterate over the tokens and create our regexp string.\n  for (var i = 0; i < tokens.length; i++) {\n    var token = tokens[i]\n\n    if (typeof token === 'string') {\n      route += escapeString(token)\n    } else {\n      var prefix = escapeString(token.prefix)\n      var capture = '(?:' + token.pattern + ')'\n\n      keys.push(token)\n\n      if (token.repeat) {\n        capture += '(?:' + prefix + capture + ')*'\n      }\n\n      if (token.optional) {\n        if (!token.partial) {\n          capture = '(?:' + prefix + '(' + capture + '))?'\n        } else {\n          capture = prefix + '(' + capture + ')?'\n        }\n      } else {\n        capture = prefix + '(' + capture + ')'\n      }\n\n      route += capture\n    }\n  }\n\n  var delimiter = escapeString(options.delimiter || '/')\n  var endsWithDelimiter = route.slice(-delimiter.length) === delimiter\n\n  // In non-strict mode we allow a slash at the end of match. If the path to\n  // match already ends with a slash, we remove it for consistency. The slash\n  // is valid at the end of a path match, not in the middle. This is important\n  // in non-ending mode, where \"/test/\" shouldn't match \"/test//route\".\n  if (!strict) {\n    route = (endsWithDelimiter ? route.slice(0, -delimiter.length) : route) + '(?:' + delimiter + '(?=$))?'\n  }\n\n  if (end) {\n    route += '$'\n  } else {\n    // In non-ending mode, we need the capturing groups to match as much as\n    // possible by using a positive lookahead to the end or next path segment.\n    route += strict && endsWithDelimiter ? '' : '(?=' + delimiter + '|$)'\n  }\n\n  return attachKeys(new RegExp('^' + route, flags(options)), keys)\n}\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n *\n * @param  {(string|RegExp|Array)} path\n * @param  {(Array|Object)=}       keys\n * @param  {Object=}               options\n * @return {!RegExp}\n */\nfunction pathToRegexp (path, keys, options) {\n  if (!isarray(keys)) {\n    options = /** @type {!Object} */ (keys || options)\n    keys = []\n  }\n\n  options = options || {}\n\n  if (path instanceof RegExp) {\n    return regexpToRegexp(path, /** @type {!Array} */ (keys))\n  }\n\n  if (isarray(path)) {\n    return arrayToRegexp(/** @type {!Array} */ (path), /** @type {!Array} */ (keys), options)\n  }\n\n  return stringToRegexp(/** @type {string} */ (path), /** @type {!Array} */ (keys), options)\n}\n",
    "var toString       = Object.prototype.toString;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * @description\n * Go from regular object syntax to a querystring style object.\n *\n * @example\n * var result = unflatten({ a: { b: 1 }, c: { d: 1 } });\n * result; //-> { \"a[b]\": 1, \"c[d]\": 2 }\n *\n * @param {Object} obj\n */\nfunction qFlat (obj, path, result) {\n\tvar type = toString.call(obj);\n\tif (result == null) {\n\t\tif (type === \"[object Object]\") result = {};\n\t\telse if (type === \"[object Array]\") result = [];\n\t\telse return;\n\t}\n\n\tfor (var key in obj) {\n\t\tvar val = obj[key];\n\t\tif (val === undefined || !hasOwnProperty.call(obj, key)) continue;\n\t\tswitch (toString.call(val)) {\n\t\t\tcase \"[object Array]\":\n\t\t\tcase \"[object Object]\":\n\t\t\t\tqFlat(val, join(path, key), result);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tresult[join(path, key)] = val;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction join (path, key) {\n\treturn path != null\n\t\t? path + \"[\" + key + \"]\"\n\t\t: key;\n}\n\nmodule.exports = qFlat;\n",
    "\"use strict\";\n\nvar matchArray   = /[^\\[\\]]+|\\[\\]/g;\nvar matchInteger = /^\\d+$/;\nvar temp         = [];\n\n/*\n * @description\n * A setter for querystring style fields like \"a[b][c]\".\n * The setter will create arrays for repeat keys.\n *\n * @param {Object} obj\n * @param {String} path\n * @param {*} val\n */\nfunction qSet (obj, path, val) {\n\tvar keys = path === \"\" ? [\"\"] : path.match(matchArray);\n\tvar len  = keys.length;\n\tvar cur  = obj;\n\tvar key, prev, next, exist;\n\n\tfor (var i = 0; i < len; i++) {\n\t\tprev = cur;\n\t\tkey  = keys[i];\n\t\tnext = keys[i + 1];\n\t\tif (key === \"[]\") key = cur.length;\n\t\t// Make path as we go.\n\t\tcur = (exist = typeof cur === \"object\" && key in cur)\n\t\t\t? cur[key]\n\t\t\t// Check if the next path is an explicit array.\n\t\t\t: cur[key] = (next === \"[]\" || matchInteger.test(next))\n\t\t\t\t? []\n\t\t\t\t: {};\n\t}\n\n\tprev[key] = exist ? temp.concat(cur, val) : val;\n\n\treturn obj;\n};\n\n/**\n * Like qset but doesn't resolve nested params such as a[b][c].\n *\n * @param {Object} obj\n * @param {String} key\n * @param {*} val\n */\nfunction fSet (obj, key, val) {\n\tkey = arrayPushIndexes(obj, key);\n\tobj[key] = key in obj\n\t\t? temp.concat(obj[key], val)\n\t\t: val;\n\treturn obj;\n}\n\n/**\n * Given a qs style key and an object will convert array push syntax to integers.\n * Eg: a[b][] -> a[b][0]\n *\n * @param {Object} obj\n * @param {String} key\n * @return {String}\n */\nfunction arrayPushIndexes (obj, key) {\n\tvar path = key.split(\"[]\");\n\tif (path.length === 1) return key;\n\tvar cur = path[0];\n\tvar keys = Object.keys(obj);\n\n\tfor (var i = 1, len = path.length; i < len; i++) {\n\t\tcur += \"[\" + findLastIndex(keys, cur) + \"]\" + path[i];\n\t}\n\n\treturn cur;\n}\n\n/**\n * Given a path to push to will return the next valid index if possible.\n * Eg: a[b][] -> 0 // if array is empty.\n *\n * @param {Array} keys\n * @param {String} path\n * @return {Number}\n */\nfunction findLastIndex (keys, path) {\n\tvar last = -1;\n\n\tfor (var key, i = keys.length; i--;) {\n\t\tkey = keys[i];\n\t\tif (key.indexOf(path) !== 0) continue;\n\t\tkey = key.replace(path, \"\");\n\t\tkey = key.slice(1, key.indexOf(\"]\"));\n\t\tif (key > last) last = Number(key);\n\t}\n\n\treturn last + 1;\n}\n\nqSet.flat      = fSet;\nmodule.exports = qSet;\n",
    "module.exports={\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"306\": \"(Unused)\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}",
    "/*!\n * statuses\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2016 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar codes = require(30)\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = status\n\n// array of status codes\nstatus.codes = populateStatusesMap(status, codes)\n\n// status codes for redirects\nstatus.redirect = {\n  300: true,\n  301: true,\n  302: true,\n  303: true,\n  305: true,\n  307: true,\n  308: true\n}\n\n// status codes for empty bodies\nstatus.empty = {\n  204: true,\n  205: true,\n  304: true\n}\n\n// status codes for when you should retry the request\nstatus.retry = {\n  502: true,\n  503: true,\n  504: true\n}\n\n/**\n * Populate the statuses map for given codes.\n * @private\n */\n\nfunction populateStatusesMap (statuses, codes) {\n  var arr = []\n\n  Object.keys(codes).forEach(function forEachCode (code) {\n    var message = codes[code]\n    var status = Number(code)\n\n    // Populate properties\n    statuses[status] = message\n    statuses[message] = status\n    statuses[message.toLowerCase()] = status\n\n    // Add to array\n    arr.push(status)\n  })\n\n  return arr\n}\n\n/**\n * Get the status code.\n *\n * Given a number, this will throw if it is not a known status\n * code, otherwise the code will be returned. Given a string,\n * the string will be parsed for a number and return the code\n * if valid, otherwise will lookup the code assuming this is\n * the status message.\n *\n * @param {string|number} code\n * @returns {number}\n * @public\n */\n\nfunction status (code) {\n  if (typeof code === 'number') {\n    if (!status[code]) throw new Error('invalid status code: ' + code)\n    return code\n  }\n\n  if (typeof code !== 'string') {\n    throw new TypeError('code must be a number or string')\n  }\n\n  // '403'\n  var n = parseInt(code, 10)\n  if (!isNaN(n)) {\n    if (!status[n]) throw new Error('invalid status code: ' + n)\n    return n\n  }\n\n  n = status[code.toLowerCase()]\n  if (!n) throw new Error('invalid status message: \"' + code + '\"')\n  return n\n}\n",
    "'use strict'\n\nvar HttpError = require(2)\nvar Request = require(34)\nvar Response = require(36)\n\n// Expose module.\nmodule.exports =\nContext['default'] = Context\n\n/**\n * Creates an incomming message context.\n *\n * @example\n * require('http').createServer((req, res) => {\n *   const ctx = new Context(req, res)\n * })\n *\n * @param {http.IncommingMessage} req - A nodejs style request object.\n * @param {http.ServerResponse} res - A nodejs style response object.\n * @constructor\n */\nfunction Context (req, res) {\n  this.req = new Request(this, req)\n  this.res = new Response(this, res)\n  this.fail = this.fail.bind(this)\n  this.assert = this.assert.bind(this)\n  this.locals = {}\n}\n\n/**\n * Throw an http during the current request and update the status and message on the response.\n *\n * @example\n * context.fail(400, 'Password is required')\n *\n * @param {number} code - The status code for the error.\n * @param {string} [message] - The status message to set on the response.\n * @param {object} [meta] - An object to merge onto the error.\n * @return {void}\n * @throws {HttpError}\n */\nContext.prototype.fail = function (code, message, meta) {\n  if (typeof code !== 'number') throw new TypeError('Rill#ctx.fail: Status code must be a number.')\n  var error = new HttpError(code, message, meta)\n  this.res.status = error.code\n  this.res.message = error.message\n  throw error\n}\n\n/**\n * If a value is falsey throw an http during the current request and update the status and message on the response.\n *\n * @example\n * context.assert(password.length > 5, 400, 'Password must be at least 5 characters long')\n *\n * @param {*} value - The value to test for truthyness.\n * @param {number} code - The status code for the error.\n * @param {string} [message] - The status message to set on the response.\n * @param {object} [meta] - An object to merge onto the error.\n * @return {void}\n * @throws {HttpError}\n */\nContext.prototype.assert = function (value, code, message, meta) {\n  if (typeof code !== 'number') throw new TypeError('Rill#ctx.assert: Status code must be a number.')\n  if (!value) this.fail(code, message, meta)\n}\n",
    "'use strict'\n\nvar pathToRegExp = require('path-to-regexp')\nvar http = require('@rill/http')\nvar https = require('@rill/https')\nvar chain = require('@rill/chain')\nvar HttpError = require('@rill/error')\nvar Context = require('./context')\nvar respond = require('./respond')\n/* istanbul ignore next */\nvar adaptBrowser = process.browser && require('@rill/http/adapter/browser')\nvar parse = pathToRegExp.parse\nvar tokensToRegExp = pathToRegExp.tokensToRegExp\nvar slice = Array.prototype.slice\n\n// Expose module.\nmodule.exports =\nRill['default'] = Rill\n\n/**\n * Creates a universal app that will run middleware for a incomming request.\n *\n * @example\n * const app = Rill()\n *\n * @constructor\n */\nfunction Rill () {\n  if (!(this instanceof Rill)) return new Rill()\n  this.stack = []\n}\n\n/**\n * Takes the current middleware stack, chains it together and\n * returns a valid handler for a node js style server request.\n *\n * @example\n * const app = Rill()\n * app.use(...)\n * require('http').createServer(app.handler()).listen()\n *\n * @return {handleIncommingMessage}\n */\nRill.prototype.handler = function () {\n  var fn = chain(this.stack)\n\n  /**\n   * Handles a node js server request and pushes it through a rill server.\n   *\n   * @param {http.IncomingMessage} req - The http request.\n   * @param {http.ServerResponse} res - The http response.\n   * @return {void}\n   */\n  return function handleIncommingMessage (req, res) {\n    res.statusCode = 404\n    var ctx = new Context(req, res)\n\n    fn(ctx)\n      .catch(handleError)\n      .then(finish)\n\n    function handleError (err) {\n      if (Number(ctx.res.status) === 404) {\n        ctx.res.status = 500\n      }\n      if (!(err instanceof HttpError)) {\n        /* istanbul ignore next */\n        console && console.error && console.error(err)\n      }\n    }\n\n    function finish () { respond(ctx) }\n  }\n}\n\n/**\n * Creates a node server from the Rill server.\n *\n * @example\n * app.createServer().listen(3000)\n *\n * @param {object} [tls] - Node https TLS options.\n * @return {http.Server}\n */\nRill.prototype.createServer = function (tls) {\n  var handler = this.handler()\n  var server = tls ? https.createServer(tls, handler) : http.createServer(handler)\n  // Setup link hijacking in the browser.\n  /* istanbul ignore next */\n  if (process.browser) adaptBrowser(server)\n  return server\n}\n\n/**\n * Creates a node server from the current Rill server and starts listening for http requests.\n *\n * @example\n * rill().use(...).listen({ port: 3000 })\n *\n * @param {object} [options] - Options to configure the node server.\n * @param {string} options.ip\n * @param {number} options.port\n * @param {number} options.backlog\n * @param {object} options.tls\n * @param {function} [onListening] - A function to be called once the server is listening for requests.\n * @returns {http.Server}\n */\nRill.prototype.listen = function (options, onListening) {\n  // Make options optional.\n  if (typeof options === 'function') {\n    onListening = options\n    options = null\n  }\n\n  options = options || {}\n  options.port = options.port != null ? options.port : 0\n  return this.createServer(options.tls).listen(options.port, options.ip, options.backlog, onListening)\n}\n\n/**\n * Append new middleware to the current rill application stack.\n *\n * @example\n * rill.use(fn1, fn2)\n *\n * @param {...function|Rill|false} [middleware] - A middleware to attach.\n * @return {this}\n */\nRill.prototype.use = function () {\n  var start = this.stack.length\n  var end = this.stack.length += arguments.length\n\n  for (var i = end; start < i--;) {\n    this.stack[i] = arguments[i - start]\n  }\n\n  return this\n}\n\n/**\n * Simple syntactic sugar for functions that\n * wish to modify the current rill instance.\n *\n * @example\n * app.setup(self => {\n *  // Modify the current app.\n *  self.use(...)\n *  self.modified = true\n * })\n *\n * @param {...function|false} [transformer] - A function that will modify the rill instance.\n * @return {this}\n */\nRill.prototype.setup = function () {\n  for (var fn, len = arguments.length, i = 0; i < len; i++) {\n    fn = arguments[i]\n    if (!fn) continue\n    if (typeof fn === 'function') fn(this)\n    else throw new TypeError('Rill#setup: Setup must be a function or falsey.')\n  }\n\n  return this\n}\n\n/**\n * Use middleware at a specific pathname.\n *\n * @example\n * app.at('/test', (ctx, next) => ...)\n *\n * @param {string} pathname - The pathname to match.\n * @param {...function|Rill|false} [middleware] - A middleware to attach.\n * @return {this}\n */\nRill.prototype.at = function (pathname) {\n  if (typeof pathname !== 'string') throw new TypeError('Rill#at: Path name must be a string.')\n\n  var keys = []\n  var reg = toReg(pathname, keys, { end: false, delimiter: '/' })\n  var fn = chain(slice.call(arguments, 1))\n\n  return this.use(function matchPathname (ctx, next) {\n    var pathname = ctx.req.matchPath\n    var matches = pathname.match(reg)\n    // Check if we matched the whole path.\n    if (!matches || matches[0] !== pathname) return next()\n\n    // Check if params match.\n    for (var key, match, i = keys.length; i--;) {\n      key = keys[i]\n      match = matches[i + 1]\n      if (key.repeat) match = match == null ? [] : match.split('/')\n      ctx.req.params[key.name] = match\n    }\n\n    // Update path for nested routes.\n    var matched = matches[matches.length - 1] || ''\n    if (ctx.req.matchPath !== matched) ctx.req.matchPath = '/' + matched\n\n    // Run middleware.\n    return fn(ctx, function () {\n      // Reset nested pathname before calling later middleware.\n      ctx.req.matchPath = pathname\n      // Run sibling middleware.\n      return next()\n    })\n  })\n}\n\n/**\n * Use middleware at a specific hostname.\n *\n * @example\n * app.host('test.com', (ctx, next) => ...)\n *\n * @param {string} hostname - The hostname to match.\n * @param {...function|Rill|false} [middleware] - A middleware to attach.\n * @return {this}\n */\nRill.prototype.host = function host (hostname) {\n  if (typeof hostname !== 'string') throw new TypeError('Rill#host: Host name must be a string.')\n\n  var keys = []\n  var reg = toReg(hostname, keys, { strict: true, delimiter: '.' })\n  var fn = chain(slice.call(arguments, 1))\n\n  return this.use(function matchHost (ctx, next) {\n    var hostname = ctx.req.matchHost\n    var matches = hostname.match(reg)\n\n    // Check if we matched the whole hostname.\n    if (!matches || matches[0] !== hostname) return next()\n\n    // Here we check for the dynamically matched subdomains.\n    for (var key, match, i = keys.length; i--;) {\n      key = keys[i]\n      match = matches[i + 1]\n      if (key.repeat) match = match == null ? [] : match.split('.')\n      ctx.req.subdomains[key.name] = match\n    }\n\n    // Update hostname for nested routes.\n    var matched = matches[matches.length - 1] || ''\n    if (ctx.req.matchHost !== matched) ctx.req.matchHost = matched\n\n    // Run middleware.\n    return fn(ctx, function () {\n      // Reset nested hostname.\n      ctx.req.matchHost = hostname\n      // Run sibling middleware.\n      return next()\n    })\n  })\n}\n\n// Attach all http verbs as shortcut methods.\nhttp.METHODS.forEach(function (method) {\n  var name = method.toLowerCase()\n  /**\n   * Use middleware on |method| requests at an (optional) pathname.\n   *\n   * @example\n   * app.|method|('/test', ...)\n   *\n   * @param {string} [pathname] - A pathname to match.\n   * @param {...function|Rill|false} [middleware] - A middleware to attach.\n   * @return {this}\n   */\n  Rill.prototype[name] = function (pathname) {\n    var offset = typeof pathname === 'string' ? 1 : 0\n    var fn = chain(slice.call(arguments, offset))\n    if (offset === 1) return this.at(pathname, matchMethod)\n    return this.use(matchMethod)\n\n    function matchMethod (ctx, next) {\n      if (ctx.req.method !== method) return next()\n      return fn(ctx, next)\n    }\n  }\n})\n\n/**\n * Small wrapper around path to regexp that treats a splat param \"/*\" as optional.\n * This makes mounting easier since typically when you do a path like \"/test/*\" you also want to treat \"/test\" as valid.\n *\n * @param {string} pathname - The path to convert to a regexp.\n * @param {array} [keys] - A place to store matched param keys.\n * @param {object} [options] - Options passed to pathToRegExp.\n * @return {RegExp}\n */\nfunction toReg (pathname, keys, options) {\n  // First parse path into tokens.\n  var tokens = parse(pathname)\n\n  // Find the last token (checking for splat params).\n  var splat = tokens[tokens.length - 1]\n\n  // Check if the last token is a splat and make it optional.\n  if (splat && splat.asterisk) splat.optional = true\n\n  // Convert the tokens to a regexp.\n  var re = tokensToRegExp(tokens, options)\n\n  // Assign keys to from regexp.\n  re.keys = keys\n  for (var i = 0, len = tokens.length; i < len; i++) {\n    if (typeof tokens[i] === 'object') keys.push(tokens[i])\n  }\n\n  return re\n}\n",
    "'use strict'\n\nvar URL = require('mini-url')\nvar QS = require('mini-querystring')\nvar cookie = require('cookie')\nvar toField = require('header-field')\nvar URL_PARTS = URL.parts\n\n// Expose module.\nmodule.exports =\nRequest['default'] = Request\n\n/**\n * Wrapper around nodejs `IncommingMessage` that has pre parsed url\n * and other conveinences.\n *\n * @param {Context} ctx - The context for the request.\n * @param {http.IncommingMessage} req - The original node request.\n * @constructor\n */\nfunction Request (ctx, req) {\n  var conn = req.connection\n  var secure = conn.encrypted\n  var protocol = secure ? 'https' : 'http'\n  var origin = protocol + '://' + req.headers.host\n  /* istanbul ignore next */\n  var parsed = process.browser ? req._options.parsed : URL.parse(req.url, origin)\n  this.ctx = ctx\n  this.original = req\n  this.method = req.method\n  this.headers = req.headers\n  this.cookies = this.headers['cookie'] ? cookie.parse(this.headers['cookie']) : {}\n  this.params = {}\n\n  // Attach url parts.\n  for (var part, i = URL_PARTS.length; i--;) {\n    part = URL_PARTS[i]\n    this[part] = parsed[part]\n  }\n\n  this.path = req.url\n  this.secure = secure\n  this.origin = origin\n  this.matchPath = this.pathname\n  this.matchHost = this.hostname\n  this.subdomains = String(this.hostname).split('.').reverse().slice(2)\n  this.query = QS.parse(this.search, true)\n  /* istanbul ignore next */\n  this.ip = (conn.remoteAddress || req.socket.remoteAddress || (conn.socket && conn.socket.remoteAddress))\n}\n\n/**\n * Utility to retrieve a header from the request.\n *\n * @example\n * request.get('Host') // -> 'test.com'\n *\n * @param {string} name - The header field to get from the request.\n * @return {string|string[]}\n */\nRequest.prototype.get = function (name) {\n  return this.headers[toField(name)]\n}\n",
    "'use strict'\n\nvar byteLength = require(11)\nvar checkType = require(14)\nvar statuses = require(31)\nvar isType = require(20)\n\n// Expose module.\nmodule.exports =\nrespond['default'] = respond\n\n/**\n * Runs general clean up on a request context and ends it with proper headers and status codes.\n *\n * @param {Context} ctx - The context of the request.\n * @return {void}\n * @private\n */\nfunction respond (ctx) {\n  var req = ctx.req\n  var res = ctx.res\n  var body = res.body\n  var original = res.original\n  var isStream = isType.stream(body)\n  var isBuffer = isType.buffer(body)\n\n  // Allow skipping response.\n  if (res.respond === false) return\n  // Skip request ended externally.\n  if (original.headersSent) return\n\n  // Apply default statuses.\n  if (Number(res.status) === 404) {\n    // Ensure redirect status.\n    if (res.get('Location')) res.status = 302\n    // Default the status to 200 if there is substance to the response.\n    else if (body) res.status = 200\n  }\n\n  // Default status message based on status code.\n  res.message = res.message || statuses[res.status]\n\n  // Ensure no content-type for empty responses.\n  if (req.method === 'HEAD' || statuses.empty[res.status] || !body) {\n    body = null\n    res.remove('Content-Type')\n    res.remove('Content-Length')\n  } else {\n    // Attempt to guess content type.\n    if (!res.get('Content-Type')) res.set('Content-Type', checkType(body))\n    // Stringify objects that are not buffers.\n    if (typeof body === 'object' && !isStream && !isBuffer) body = JSON.stringify(body)\n    // Attempt to guess content-length.\n    if (!res.get('Content-Length') && !isStream) res.set('Content-Length', byteLength(body))\n  }\n\n  // Send off headers.\n  original.writeHead(res.status, res.message, removeEmptyHeaders(res.headers))\n  // Allow for requests to stay open.\n  if (res.end === false) return\n  // Finish response.\n  if (isStream) body.pipe(original)\n  else original.end(body)\n}\n\n/**\n * Utility to remove empty values from an object.\n *\n * @example\n * removeEmptyHeaders({ a: [], b: null, c: 0 }) // -> { c: 0 }\n *\n * @param {object} obj - The headers object to remove empties from.\n * @return {object}\n * @private\n */\nfunction removeEmptyHeaders (obj) {\n  for (var key in obj) {\n    if (obj[key] == null || obj[key].length === 0) {\n      delete obj[key]\n    }\n  }\n  return obj\n}\n",
    "'use strict'\n\nvar URL = require(23)\nvar cookie = require(15)\nvar statuses = require(31)\nvar toField = require(19)\n\n// Expose module.\nmodule.exports =\nResponse['default'] = Response\n\n/**\n * Wrapper around nodejs `ServerResponse`.\n *\n * @param {Context} ctx - The context for the request.\n * @param {http.ServerResponse} res - The original node response.\n * @constructor\n */\nfunction Response (ctx, original) {\n  this.ctx = ctx\n  this.original = original\n  this.status = original.statusCode\n  this.headers = {}\n  this.body = undefined\n  original.once('finish', function () { ctx.res.finished = true })\n}\n\n/**\n * Utility to retrieve a header from the response headers.\n *\n * @example\n * response.get('Content-Type')\n *\n * @param {string} name - The name of the header to get.\n * @return {string|string[]}\n */\nResponse.prototype.get = function (name) {\n  return this.headers[toField(name)]\n}\n\n/**\n * @description\n * Utility to overwrite a header on the response headers.\n *\n * @example\n * response.set('Content-Type', 'text/html')\n *\n * @param {string} name - The name of the header to set.\n * @param {string|string[]} value - The value for the header.\n */\nResponse.prototype.set = function (name, value) {\n  this.headers[toField(name)] = value\n}\n\n/**\n * Utility to add or set a header on the response headers.\n *\n * @example\n * response.append('Set-Cookie', 'a=1')\n * response.append('Set-Cookie', 'b=1')\n * response.get('Set-Cookie') // -> ['a=1', 'b=1']\n *\n * @param {string} name - The name of the header to append to.\n * @param {string|string[]} - value The value to append.\n * return {void}\n */\nResponse.prototype.append = function (name, value) {\n  name = toField(name)\n  var headers = this.headers\n  var cur = this.headers[name]\n\n  if (cur == null) cur = []\n  else if (!Array.isArray(cur)) cur = [cur]\n\n  headers[name] = cur.concat(value)\n}\n\n/**\n * Utility to remove a header from the response headers.\n *\n * @example\n * response.remove('Content-Type')\n *\n * @param {string} name The name of the header to remove.\n * @return {void}\n */\nResponse.prototype.remove = function (name) {\n  delete this.headers[toField(name)]\n}\n\n/**\n * Appends to the current set-cookie header, adding a new cookie with options.\n *\n * @example\n * response.cookie('auth-token', 'abc123', { httoOnly: true })\n *\n * @param {string} name - The name of the cookie.\n * @param {*} value - The value for the cookie.\n * @param {object} [options] - Options for the cookie.\n * @return {void}\n */\nResponse.prototype.cookie = function (name, value, options) {\n  this.append('Set-Cookie', cookie.serialize(name, value, options))\n}\n\n/**\n * Deletes a cookie from the current set-cookie header.\n *\n * @example\n * response.clearCookie('auth-token')\n *\n * @param {string} name - The name of the cookie.\n * @param {object} [options] - Options for the cookie.\n * @return {void}\n */\nResponse.prototype.clearCookie = function (name, options) {\n  options = options || {}\n  options.expires = new Date()\n  this.append('Set-Cookie', cookie.serialize(name, '', options))\n}\n\n/**\n * Attaches location headers relative to the current request to perform a redirect.\n * Will redirect to the referrer if \"back\" is supplied as a url.\n *\n * @example\n * response.redirect('/home') // redirect back to home page.\n *\n * @param {string} url - The url to redirect too or \"back\".\n * @param {string} [alt] - Used if the url is empty or \"back\" does not exist.\n * @return {void}\n */\nResponse.prototype.redirect = function (url, alt) {\n  var req = this.ctx.req\n\n  // Back uses request referrer header as a url.\n  url = (url === 'back') ? req.get('Referrer') : url\n  // Default url to alternative.\n  url = url || alt\n\n  if (!url) {\n    throw new TypeError('Rill#ctx.res.redirect: Cannot redirect, url not specified and alternative not provided.')\n  }\n\n  if (!statuses.redirect[this.status]) this.status = 302\n\n  this.set('Location', URL.parse(url, req.href).href)\n}\n\n/**\n * Attaches refresh headers relative to the current request to perform a timed refresh of the page.\n * Will refresh to the referrer if \"back\" is supplied as a url.\n *\n * @example\n * response.refresh(2, '/home') // redirect the user home after 2 seconds.\n *\n * @param {number|string} delay - Delays the refresh by `delay` seconds.\n * @param {string} url - The url to refresh or \"back\".\n * @param {string} alt - Used if the url is empty or \"back\" does not exist.\n * @return {void}\n */\nResponse.prototype.refresh = function (delay, url, alt) {\n  var req = this.ctx.req\n\n  delay = delay || 0\n  // Back uses request referrer header as a url.\n  url = (url === 'back') ? req.get('Referrer') : url\n  // Default url to alternative.\n  url = url || alt || req.href\n\n  this.set('Refresh', delay + '; url=' + URL.parse(url, req.href).href)\n}\n"
  ]
}